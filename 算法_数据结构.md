//ref
https://blog.algomooc.com/LeetCode/%E7%AC%AC%E4%B8%80%E5%91%A8/%E7%AC%AC%E4%BA%8C%E5%A4%A9/LeetCode%2027%E3%80%81%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0
https://github.com/doocs/leetcode/blob/main/solution/README.md
https://greyireland.gitbook.io/algorithm-pattern/

学习参考

```
https://www.hello-algo.com/chapter_array_and_linkedlist/array/#2
https://visualgo.net/zh/heap
```





1.时间复杂度
	时间复杂度分析统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。

![image-20240308133325184](算法_数据结构.assets/image-20240308133325184.png)

数字编码

**数字是以“补码”的形式存储在计算机中的**

![image-20240308134443840](算法_数据结构.assets/image-20240308134443840.png)

## 哈希表

存储 键和值   key-> 映射关系(hash函数)   得到值

```
哈希函数:
1）直接定址法
取关键字或者关键字的某个线性函数为Hash地址，即Hash(key)=a*key+b

2）除留余数法
如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，Hash(key)=key%p。
在这里p的选取非常关键，p选择的好的话，能够最大程度地减少冲突，p一般取不大于m的最大质数。

3）平方取中法
对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址。

4）折叠法
将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将Hash(key)=89+03+24+12+3作为Hash地址。

冲突解决:
开放定址法  取下一个空的地址  fi（key）=（f（key）+di）MOD m（di=1,2,3,……,m-1） 线性探测法
		(参考 大话数据结构 8.11　处理散列冲突的方法 节	)
			
分离链接法（链地址法）   key 相同的用单链表链接

```

![image-20240126150234562](算法_数据结构.assets/image-20240126150234562.png)

?														链地址法图解

```
/* 初始化哈希表 */
unordered_map<int, string> map;

/* 添加操作 */
// 在哈希表中添加键值对 (key, value)
map[12836] = "小哈";
map[15937] = "小";
map[16750] = "小算";
map[13276] = "小法";
map[10583] = "小鸭";

/* 查询操作 */
// 向哈希表中输入键 key ，得到值 value
string name = map[15937];

/* 删除操作 */
// 在哈希表中删除键值对 (key, value)
map.erase(10583);
```



## 二叉树

概念、常用术语

```
节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。
节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。
二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。
```





## 算法

### 1.排序算法



